/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.cereal.stockx.api

import com.cereal.stockx.api.model.ActivateListingInput
import com.cereal.stockx.api.model.CreateListingInput
import com.cereal.stockx.api.model.ListingAsyncOperationResponse
import com.cereal.stockx.api.model.ListingResponse
import com.cereal.stockx.api.model.Listings
import com.cereal.stockx.api.model.OperationApi
import com.cereal.stockx.api.model.OperationsCursorResponse
import com.cereal.stockx.api.model.PublicApiError
import com.cereal.stockx.api.model.UpdateListingInput

import org.openapitools.client.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import io.ktor.http.ParametersBuilder

    open class ListingsApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    ) : ApiClient(
        baseUrl,
        httpClientEngine,
        httpClientConfig,
    ) {

        /**
        * PUT /selling/listings/{listingId}/activate
        * Activate a listing
        * Activate listing API allows you to activate a listing. A listing is active when it contains an available ask.
         * @param listingId Unique ID for this listing 
         * @param activateListingInput  
         * @return ListingAsyncOperationResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun activateListing(listingId: kotlin.String, activateListingInput: ActivateListingInput): HttpResponse<ListingAsyncOperationResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = activateListingInput

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/selling/listings/{listingId}/activate".replace("{" + "listingId" + "}", "$listingId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * POST /selling/listings
        * Create a new listing
        * Create listings API allows you to create new listings. The listings correspond to an ask in the StockX UI. The listings can be for the same variant ID.
         * @param createListingInput  
         * @return ListingAsyncOperationResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun create(createListingInput: CreateListingInput): HttpResponse<ListingAsyncOperationResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = createListingInput

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/selling/listings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * PUT /selling/listings/{listingId}/deactivate
        * Deactivate a listing
        * Deactivate listing API allows you to deactivate a listing. A listing is deactivated when it doesn&#39;t have an ask or when it contains an expired ask.
         * @param listingId Unique ID for this listing 
         * @return ListingAsyncOperationResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun deactivateListing(listingId: kotlin.String): HttpResponse<ListingAsyncOperationResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/selling/listings/{listingId}/deactivate".replace("{" + "listingId" + "}", "$listingId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * DELETE /selling/listings/{listingId}
        * Delete a listing
        * Operation used to delete an existing listing by its ID.
         * @param listingId Unique ID for this listing 
         * @return ListingAsyncOperationResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun deleteListing(listingId: kotlin.String): HttpResponse<ListingAsyncOperationResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/selling/listings/{listingId}".replace("{" + "listingId" + "}", "$listingId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/listings/{listingId}
        * Get single listing
        * Get a listing API allows you to get a listing by its ID.
         * @param listingId Unique ID for this listing 
         * @return ListingResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun findById(listingId: kotlin.String): HttpResponse<ListingResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/listings/{listingId}".replace("{" + "listingId" + "}", "$listingId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/listings/{listingId}/operations/{operationId}
        * Get single listing operation
        * Get listing operation API allows you to fetch a listing operation by listing ID and operation ID
         * @param listingId Unique ID for this listing. 
         * @param operationId Unique ID for this operation. 
         * @return OperationApi
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun findOperationById(listingId: kotlin.String, operationId: kotlin.String): HttpResponse<OperationApi> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/listings/{listingId}/operations/{operationId}".replace("{" + "listingId" + "}", "$listingId").replace("{" + "operationId" + "}", "$operationId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/listings
        * Get all listings
        * Get all listings API allows you to fetch all existing listings. Multiple filters are available.
         * @param pageNumber Requested page number. By default the page number starts at 1 (optional)
         * @param pageSize The number of listings to return. By default the page size starts at 1. (optional)
         * @param productIds Comma separated list of ids. This field must not include array brackets &#x60;[]&#x60; or quotation marks (\&quot; \&quot; | &#39; &#39;). (optional)
         * @param variantIds Comma separated list of ids. This field must not include array brackets &#x60;[]&#x60; or quotation marks (\&quot; \&quot; | &#39; &#39;). (optional)
         * @param batchIds Comma separated list of ids. This field must not include array brackets &#x60;[]&#x60; or quotation marks (\&quot; \&quot; | &#39; &#39;). (optional)
         * @param fromDate Start date of the query (optional)
         * @param toDate End date of the query (optional)
         * @param listingStatuses Comma separated list of listing statuses. This field must not include array brackets &#x60;[]&#x60; or quotation marks (\&quot;\&quot; | &#39;&#39;).&lt;br&gt;&lt;br&gt;Available values: \&quot;INACTIVE\&quot;, \&quot;ACTIVE\&quot;, \&quot;DELETED\&quot;, \&quot;CANCELED\&quot;, \&quot;MATCHED\&quot;, \&quot;COMPLETED\&quot; (optional)
         * @param inventoryTypes Comma-separated list of inventory type(s). This field must not include array brackets [] or quotation marks (\&quot;| &#39;&#39;). The inventory types are STANDARD or FLEX. (optional)
         * @param initiatedShipmentDisplayIds The shipment&#39;s unique display id associated with the listing. Note: This is the same ID generated when a Flex inbound list is created in StockX Pro. (optional)
         * @return Listings
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun getAllListings(pageNumber: kotlin.Int?, pageSize: kotlin.Int?, productIds: kotlin.String?, variantIds: kotlin.String?, batchIds: kotlin.String?, fromDate: kotlin.String?, toDate: kotlin.String?, listingStatuses: kotlin.String?, inventoryTypes: kotlin.String?, initiatedShipmentDisplayIds: kotlin.String?): HttpResponse<Listings> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            pageNumber?.apply { localVariableQuery["pageNumber"] = listOf("$pageNumber") }
            pageSize?.apply { localVariableQuery["pageSize"] = listOf("$pageSize") }
            productIds?.apply { localVariableQuery["productIds"] = listOf("$productIds") }
            variantIds?.apply { localVariableQuery["variantIds"] = listOf("$variantIds") }
            batchIds?.apply { localVariableQuery["batchIds"] = listOf("$batchIds") }
            fromDate?.apply { localVariableQuery["fromDate"] = listOf("$fromDate") }
            toDate?.apply { localVariableQuery["toDate"] = listOf("$toDate") }
            listingStatuses?.apply { localVariableQuery["listingStatuses"] = listOf("$listingStatuses") }
            inventoryTypes?.apply { localVariableQuery["inventoryTypes"] = listOf("$inventoryTypes") }
            initiatedShipmentDisplayIds?.apply { localVariableQuery["initiatedShipmentDisplayIds"] = listOf("$initiatedShipmentDisplayIds") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/listings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/listings/{listingId}/operations
        * Get all listing operations
        * Get all listing operations API allows you to fetch a paginated list of single listing with all operations.
         * @param listingId Unique ID for this listing 
         * @param pageSize Requested page number. Starts at 1. (optional)
         * @param cursor The cursor to use as a starting point (optional)
         * @return OperationsCursorResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun getListingOperations(listingId: kotlin.String, pageSize: kotlin.Int?, cursor: kotlin.String?): HttpResponse<OperationsCursorResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            pageSize?.apply { localVariableQuery["pageSize"] = listOf("$pageSize") }
            cursor?.apply { localVariableQuery["cursor"] = listOf("$cursor") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/listings/{listingId}/operations".replace("{" + "listingId" + "}", "$listingId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * PATCH /selling/listings/{listingId}
        * Update a listing
        * Operation used to update an existing listing by its ID.
         * @param listingId Unique ID for this listing 
         * @param updateListingInput  
         * @return ListingAsyncOperationResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun update(listingId: kotlin.String, updateListingInput: UpdateListingInput): HttpResponse<ListingAsyncOperationResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = updateListingInput

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/selling/listings/{listingId}".replace("{" + "listingId" + "}", "$listingId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        }
