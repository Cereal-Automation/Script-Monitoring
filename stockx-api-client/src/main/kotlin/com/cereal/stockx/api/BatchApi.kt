/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.cereal.stockx.api

import com.cereal.stockx.api.model.BatchCreateListingInput
import com.cereal.stockx.api.model.BatchCreateListingResponse
import com.cereal.stockx.api.model.BatchDeleteListingInput
import com.cereal.stockx.api.model.BatchDeleteListingResponse
import com.cereal.stockx.api.model.BatchUpdateListingInput
import com.cereal.stockx.api.model.BatchUpdateListingResponse
import com.cereal.stockx.api.model.GetListingCreateBatchItemsResponse
import com.cereal.stockx.api.model.GetListingCreateBatchResponse
import com.cereal.stockx.api.model.GetListingDeleteBatchItemsResponse
import com.cereal.stockx.api.model.GetListingDeleteBatchResponse
import com.cereal.stockx.api.model.GetListingUpdateBatchItemsResponse
import com.cereal.stockx.api.model.GetListingUpdateBatchResponse
import com.cereal.stockx.api.model.PublicApiError

import org.openapitools.client.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import io.ktor.http.ParametersBuilder

    open class BatchApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    ) : ApiClient(
        baseUrl,
        httpClientEngine,
        httpClientConfig,
    ) {

        /**
        * POST /selling/batch/create-listing
        * Batch listings creation
        * Create a new batch of listings
         * @param batchCreateListingInput  
         * @return BatchCreateListingResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun createListings(batchCreateListingInput: BatchCreateListingInput): HttpResponse<BatchCreateListingResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = batchCreateListingInput

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/selling/batch/create-listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * POST /selling/batch/delete-listing
        * Batch listings deletion
        * Batch delete listings API allows a user to delete up to 100 individual listings in a single API call. This API is asynchronous in nature and will return a batchId that you would need to poll using the polling APIs described later.
         * @param batchDeleteListingInput  
         * @return BatchDeleteListingResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun deleteListings(batchDeleteListingInput: BatchDeleteListingInput): HttpResponse<BatchDeleteListingResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = batchDeleteListingInput

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/selling/batch/delete-listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/batch/create-listing/{batchId}
        * Batch listings creation - Get Batch Status
        * Once you are able to create a batch successfully, you need to poll the get batch status API to track the progress of the batch. This polling is necessary because all batch operations are asynchronous in nature.
         * @param batchId Unique Batch ID 
         * @return GetListingCreateBatchResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun getListingCreateBatch(batchId: kotlin.String): HttpResponse<GetListingCreateBatchResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/batch/create-listing/{batchId}".replace("{" + "batchId" + "}", "$batchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/batch/create-listing/{batchId}/items
        * Batch listings creation - Get Items
        * Once a batch completes successfully, you need to use the get batch items API to see the results of each item in the batch. You can also use this API at any point in time after the batch is created to see the progress of each individual item in a batch.
         * @param batchId The ID of batch 
         * @param status Status of listing (optional)
         * @return GetListingCreateBatchItemsResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun getListingCreateBatchItems(batchId: kotlin.String, status: kotlin.String?): HttpResponse<GetListingCreateBatchItemsResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            status?.apply { localVariableQuery["status"] = listOf("$status") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/batch/create-listing/{batchId}/items".replace("{" + "batchId" + "}", "$batchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/batch/delete-listing/{batchId}
        * Batch listings deletion - Get Batch Status
        * Once you are able to create a batch successfully, you need to poll the get batch status API to track the progress of the batch. This polling is necessary because all batch operations are asynchronous in nature.
         * @param batchId Unique Batch ID 
         * @return GetListingDeleteBatchResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun getListingDeleteBatch(batchId: kotlin.String): HttpResponse<GetListingDeleteBatchResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/batch/delete-listing/{batchId}".replace("{" + "batchId" + "}", "$batchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/batch/delete-listing/{batchId}/items
        * Batch listings deletion - Get Items
        * Once a batch completes successfully, you need to use the get batch items API to see the results of each item in the batch. You can also use this API at any point in time after the batch is created to see the progress of each individual item in a batch.
         * @param batchId Unique Batch ID 
         * @param status  (optional)
         * @return GetListingDeleteBatchItemsResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun getListingDeleteBatchItems(batchId: kotlin.String, status: kotlin.String?): HttpResponse<GetListingDeleteBatchItemsResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            status?.apply { localVariableQuery["status"] = listOf("$status") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/batch/delete-listing/{batchId}/items".replace("{" + "batchId" + "}", "$batchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/batch/update-listing/{batchId}
        * Batch listings update - Get Batch Status
        * Once you are able to create a batch successfully, you need to poll the get batch status API to track the progress of the batch. This polling is necessary because all batch operations are asynchronous in nature.
         * @param batchId Unique Batch ID 
         * @return GetListingUpdateBatchResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun getListingUpdateBatch(batchId: kotlin.String): HttpResponse<GetListingUpdateBatchResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/batch/update-listing/{batchId}".replace("{" + "batchId" + "}", "$batchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /selling/batch/update-listing/{batchId}/items
        * Batch listings update - Get Items
        * Once a batch completes successfully, you need to use the get batch items API to see the results of each item in the batch. You can also use this API at any point in time after the batch is created to see the progress of each individual item in a batch
         * @param batchId Unique Batch ID 
         * @param status Status of listing (optional)
         * @return GetListingUpdateBatchItemsResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun getListingUpdateBatchItems(batchId: kotlin.String, status: kotlin.String?): HttpResponse<GetListingUpdateBatchItemsResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            status?.apply { localVariableQuery["status"] = listOf("$status") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/selling/batch/update-listing/{batchId}/items".replace("{" + "batchId" + "}", "$batchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * POST /selling/batch/update-listing
        * Batch listings update
        * Batch update listings API allows a user to update up to 100 individual listings in a single API call. This API is asynchronous in nature and will return a batchId that you would need to poll using the polling APIs described later.
         * @param batchUpdateListingInput  
         * @return BatchUpdateListingResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun updateListings(batchUpdateListingInput: BatchUpdateListingInput): HttpResponse<BatchUpdateListingResponse> {

            val localVariableAuthNames = listOf<String>("api_key", "jwt")

            val localVariableBody = batchUpdateListingInput

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/selling/batch/update-listing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            )

            return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        }
